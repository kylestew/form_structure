---
title: 'Chaikin Curves: Creating Smooth Lines in Generative Art'
publishedAt: '2024-04-08'
summary: 'Explore how Chaikin curves can be used to create smooth, organic lines in generative art and creative coding.'
image: chaikin-curves.png
---

```js
// @meta exec store:utils
// hidden utility functions
function drawPolyline(ctx, polyline, closed = false) {
    ctx.beginPath()
    ctx.moveTo(polyline[0][0], polyline[0][1])
    for (let i = 1; i < polyline.length; i++) {
        ctx.lineTo(polyline[i][0], polyline[i][1])
    }
    if (closed && polyline.length > 2) {
        ctx.lineTo(polyline[0][0], polyline[0][1])
    }
    ctx.stroke()
}
function drawPoint(ctx, point, size = 2) {
    ctx.beginPath()
    ctx.arc(point[0], point[1], size, 0, Math.PI * 2)
    ctx.fill()
}
```

> Chaikin curves, developed by George Chaikin in 1974, offer a simple yet powerful way to create smooth curves from a series of points. In generative art, they provide an elegant method for transforming rigid, angular lines into flowing, organic shapes.

## What are Chaikin Curves?

At its core, Chaikin's algorithm is a corner-cutting method. It works by repeatedly **replacing** each line segment with two new points that are positioned a fraction of the way in from each end (typically 1/4 and 3/4 along the line). After several iterations, this process transforms a polygonal line into a smooth curve.

_Note: The final result is shorter than the original line._

## The Algorithm

Here's a simple (recursive, so not simple) implementation of the Chaikin curve algorithm:

```javascript
// @meta store:algo
// points are defined as [[x, y], [x, y], ...]
function chaikinCurve(points, iterations) {
    if (iterations === 0) return points

    let newPoints = []
    for (let i = 0; i < points.length - 1; i++) {
        const [p0x, p0y] = points[i]
        const [p1x, p1y] = points[i + 1]

        // Create two new points at 1/4 and 3/4 along the line
        const q0 = [
            p0x * 0.75 + p1x * 0.25, //
            p0y * 0.75 + p1y * 0.25,
        ]

        const q1 = [
            p0x * 0.25 + p1x * 0.75, //
            p0y * 0.25 + p1y * 0.75,
        ]

        newPoints.push(q0, q1)
    }

    return chaikinCurve(newPoints, iterations - 1)
}
```

## Animated Example

<Canvas id="example01" />

```js
// @meta exec load:algo load:utils
function drawFrame() {
    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    ctx.strokeStyle = 'white'

    ctx.lineWidth = 6
    ctx.lineJoin = 'round'
    ctx.lineCap = 'round'

    // baseline
    const polyline = [
        [40, 40],
        [150, 300],
        [280, 200],
        [420, 440],
    ]

    // one iteration
    let curve = chaikinCurve(polyline, tick++)
    drawPolyline(ctx, curve)

    // draw points
    ctx.fillStyle = 'red'
    for (let i = 0; i < curve.length; i++) {
        drawPoint(ctx, curve[i])
    }

    if (tick > maxTick) tick = 1
    setTimeout(() => requestAnimationFrame(drawFrame), tickInterval)
}

let tick = 1
const maxTick = 6
const tickInterval = 1000
const canvas = document.getElementById('example01')
const ctx = canvas.getContext('2d')
requestAnimationFrame(drawFrame)
```

## Tips for Creative Coding

When using Chaikin curves in your generative art:

1. **Iteration Count**: 2-4 iterations usually provide a good balance between smoothness and performance
2. **Cutting Ratio**: Experiment with different ratios instead of the standard 0.25/0.75
3. **Point Distribution**: The initial distribution of points greatly affects the final curve
4. **Animation**: Try animating between different iteration counts or cutting ratios

## Generative Art Example

<Canvas id="example02" />

```javascript
// Example: Creating a flowing line with noise
```

```js
// @meta exec load:algo load:utils
function flowingLine(time) {
    const points = []
    const radius = 140
    const centerX = 240
    const centerY = 240

    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2
        const wobble = Math.sin(time * 2 + i * 2) * 40
        points.push([centerX + Math.cos(angle) * (radius + wobble), centerY + Math.sin(angle) * (radius + wobble)])
    }
    points.push([...points[0]]) // Close the circle
    return [[...points], chaikinCurve(points, 3)]
}

function drawFrame(time) {
    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    ctx.strokeStyle = 'white'

    ctx.lineWidth = 6
    ctx.lineJoin = 'round'
    ctx.lineCap = 'round'

    // draw points
    const [points, curve] = flowingLine(time * 0.001)
    drawPolyline(ctx, curve)

    ctx.fillStyle = 'red'
    for (let i = 0; i < points.length; i++) {
        drawPoint(ctx, points[i])
    }

    requestAnimationFrame(drawFrame)
}

// let tick = 1
// const maxTick = 6
const tickInterval = 100
const canvas = document.getElementById('example02')
const ctx = canvas.getContext('2d')
requestAnimationFrame(drawFrame)
```

### References

-   [Chaikin's Algorithm on Observable](https://observablehq.com/@pamacha/chaikins-algorithm)
-   [Chaikin Curves on Sighack](https://sighack.com/post/chaikin-curves)
