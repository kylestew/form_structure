---
title: 'Chaikin Curves: Creating Smooth Lines in Generative Art'
publishedAt: '2024-04-08'
summary: 'Explore how Chaikin curves can be used to create smooth, organic lines in generative art and creative coding.'
image: chaikin.png
---

### References

https://observablehq.com/@pamacha/chaikins-algorithm

https://github.com/kylestew/root/blob/ether/src/algos/chaikin.ts

---

> Chaikin curves, developed by George Chaikin in 1974, offer a simple yet powerful way to create smooth curves from a series of points. In generative art, they provide an elegant method for transforming rigid, angular lines into flowing, organic shapes.

## What are Chaikin Curves?

At its core, Chaikin's algorithm is a corner-cutting method. It works by repeatedly **replacing** each line segment with two new points that are positioned a fraction of the way in from each end (typically 1/4 and 3/4 along the line). After several iterations, this process transforms a polygonal line into a smooth curve.

_Note: The final result is shorter than the original line._

## The Algorithm

Here's a simple (recursive, so not simple) implementation of the Chaikin curve algorithm:

```javascript
// @meta store:algo
// points are defined as [[x, y], [x, y], ...]
function chaikinCurve(points, iterations) {
    if (iterations === 0) return points

    let newPoints = []
    for (let i = 0; i < points.length - 1; i++) {
        const [p0x, p0y] = points[i]
        const [p1x, p1y] = points[i + 1]

        // Create two new points at 1/4 and 3/4 along the line
        const q0 = {
            x: p0x * 0.75 + p1x * 0.25,
            y: p0y * 0.75 + p1y * 0.25,
        }

        const q1 = {
            x: p0x * 0.25 + p1x * 0.75,
            y: p0y * 0.25 + p1y * 0.75,
        }

        newPoints.push(q0, q1)
    }

    return chaikinCurve(newPoints, iterations - 1)
}
```

## Animated Example

<Canvas id="example01" width="200" height="200" />

```js
// @meta exec load:algo

const canvas = document.getElementById('example01')
if (canvas?.getContext) {
    const ctx = canvas.getContext('2d')

    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    ctx.fillStyle = 'white'
    ctx.strokeStyle = 'white'

    // Draw points
    const points = [
        [100, 200],
        [200, 300],
        [300, 400],
    ]
    points.forEach((point) => drawPoint(ctx, point))

    // Draw lines
    const lines = [
        [
            [100, 100],
            [200, 200],
        ],
        [
            [220, 220],
            [260, 320],
        ],
    ]
    lines.forEach((line) => drawLine(ctx, line))
}
```

## My Implementation

```javascript
import { Vec2 } from '../geo/types'

/**
 * Generates a Chaikin curve based on the given points and number of iterations.
 *
 * @param {Array} points - The input points for the curve.
 * @param {number} iterations - The number of iterations to perform.
 * @param {boolean} closed - Whether the polygon is closed or not.
 * @returns {Array} The generated Chaikin curve as an array of points.
 */
export function chaikinCurve(points: Vec2[], iterations: number, closed = false): Vec2[] {
    if (iterations === 0) return points
    // Chaikin subdivision with consideration for closed or open polygons
    const smooth = chaikinSubdivide(points, closed)
    return iterations === 1 ? smooth : chaikinCurve(smooth, iterations - 1, closed)
}

/**
 * Subdivides the given points using the Chaikin algorithm.
 *
 * @param {Array} points - The input points to subdivide.
 * @param {boolean} closed - Whether the polygon is closed or not.
 * @returns {Array} The subdivided points.
 */
function chaikinSubdivide(points: Vec2[], closed: boolean): Vec2[] {
    const result: Vec2[] = []
    const n = points.length

    for (let i = 0; i < n - 1; i++) {
        const a = points[i]
        const b = points[i + 1]

        const p1: Vec2 = [0.75 * a[0] + 0.25 * b[0], 0.75 * a[1] + 0.25 * b[1]]
        const p2: Vec2 = [0.25 * a[0] + 0.75 * b[0], 0.25 * a[1] + 0.75 * b[1]]

        result.push(p1, p2)
    }

    if (closed) {
        const a = points[n - 1]
        const b = points[0]

        const p1: Vec2 = [0.75 * a[0] + 0.25 * b[0], 0.75 * a[1] + 0.25 * b[1]]
        const p2: Vec2 = [0.25 * a[0] + 0.75 * b[0], 0.25 * a[1] + 0.75 * b[1]]

        result.push(p1, p2)
    } else {
        result.unshift(points[0])
        result.push(points[n - 1])
    }

    return result
}
```

## Applications in Generative Art

Chaikin curves have several compelling applications in generative art:

### 1. Organic Line Drawing

One of the most straightforward uses is creating natural-looking lines. Instead of drawing straight lines between points, applying the Chaikin algorithm creates smooth, organic curves that can simulate natural phenomena like:

-   Plant growth patterns
-   River paths
-   Mountain ridges
-   Cloud boundaries

### 2. Shape Morphing

By applying different iteration counts or cutting ratios, you can create interesting morphing effects:

```javascript
function morphingShape(time) {
    const basePoints = createPolygon(5, 100) // Create a pentagon
    const iterations = 1 + Math.sin(time) * 3 // Vary between 1-4 iterations
    return chaikinCurve(basePoints, Math.floor(iterations))
}
```

### 3. Pattern Generation

Chaikin curves can be used to create complex patterns by:

-   Applying the algorithm to geometric shapes
-   Nesting curves within curves
-   Using curves as paths for other elements

## Interactive Example

```javascript
{
    ;(() => {
        const [iterations, setIterations] = useState(0)
        const basePoints = [
            { x: 50, y: 50 },
            { x: 150, y: 50 },
            { x: 150, y: 150 },
            { x: 50, y: 150 },
            { x: 50, y: 50 },
        ]

        const points = iterations === 0 ? basePoints : chaikinCurve(basePoints, iterations)

        return (
            <div className="my-4 p-4 border rounded">
                <div className="mb-4">
                    <button
                        onClick={() => setIterations((prev) => Math.min(prev + 1, 4))}
                        className="mr-2 px-3 py-1 rounded bg-action text-white"
                    >
                        Add Iteration
                    </button>
                    <button onClick={() => setIterations(0)} className="px-3 py-1 rounded bg-gray-200">
                        Reset
                    </button>
                </div>
                <svg width="200" height="200" className="border">
                    <path
                        d={`M ${points.map((p) => `${p.x} ${p.y}`).join(' L ')}`}
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                    />
                </svg>
                <div className="mt-2 text-sm">Iterations: {iterations}</div>
            </div>
        )
    })()
}
```

## Mathematical Properties

While Chaikin curves are simpler than other curve algorithms like Bézier curves or B-splines, they have interesting mathematical properties:

1. They converge to a quadratic B-spline curve
2. Each iteration removes one quarter of the distance between points
3. The resulting curve is C¹ continuous (continuous in both position and first derivative)

## Tips for Creative Coding

When using Chaikin curves in your generative art:

1. **Iteration Count**: 2-4 iterations usually provide a good balance between smoothness and performance
2. **Cutting Ratio**: Experiment with different ratios instead of the standard 0.25/0.75
3. **Point Distribution**: The initial distribution of points greatly affects the final curve
4. **Animation**: Try animating between different iteration counts or cutting ratios

## Conclusion

Chaikin curves provide a perfect example of how a simple algorithm can create complex, organic results. Their efficiency and versatility make them an invaluable tool in generative art, whether you're creating flowing lines, morphing shapes, or complex patterns.

```javascript
// Example: Creating a flowing line with noise
function flowingLine(time) {
    const points = []
    for (let i = 0; i < 10; i++) {
        points.push({
            x: i * 50,
            y: 100 + Math.sin(i * 0.5 + time) * 30,
        })
    }
    return chaikinCurve(points, 3)
}
```

Whether you're new to generative art or an experienced creative coder, Chaikin curves offer endless possibilities for exploration and creation. Their simplicity makes them accessible, while their results can be surprisingly sophisticated.
