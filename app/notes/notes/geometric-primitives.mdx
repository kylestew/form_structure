---
title: 'Simple Geometric Primitives'
publishedAt: '2024-04-08'
summary: 'A practical look at representing basic geometric shapes in code - points, lines, circles, and rectangles.'
image: primitives.png
---

When working with geometric shapes in creative coding, I prefer to keep things as simple as possible. Here's how I represent and work with basic geometric primitives, focusing on clarity and simplicity over complex object-oriented approaches.

## Points

The simplest representation - just x and y coordinates:

```js
const point = [100, 200]
```

Some examples using point data:

```js
// @meta store:points
function drawPoint(ctx, point) {
    ctx.beginPath()
    ctx.arc(point[0], point[1], 2, 0, Math.PI * 2)
    ctx.fill()
}

function distance(p1, p2) {
    const dx = p2[0] - p1[0]
    const dy = p2[1] - p1[1]
    return Math.sqrt(dx * dx + dy * dy)
}
```

## Lines

A line is just two points. I usually represent it as either start and end points or a point with a direction:

```js
// Line as two points
const line = [
    [100, 100],
    [200, 200],
]
```

Some examples using line data:

```js
// @meta store:lines
function drawLine(ctx, line) {
    ctx.beginPath()
    ctx.moveTo(line[0][0], line[0][1])
    ctx.lineTo(line[1][0], line[1][1])
    ctx.stroke()
}

function pointOnLine(line, t) {
    return {
        x: line.start.x + (line.end.x - line.start.x) * t, //
        y: line.start.y + (line.end.y - line.start.y) * t,
    }
}
```

## Full Example

<Canvas id="example01" />

```js
// @meta exec load:points load:lines

const canvas = document.getElementById('example01')
if (canvas?.getContext) {
    const ctx = canvas.getContext('2d')

    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    ctx.fillStyle = 'white'
    ctx.strokeStyle = 'white'

    // Draw points
    const points = [
        [100, 200],
        [200, 300],
        [300, 400],
    ]
    points.forEach((point) => drawPoint(ctx, point))

    // Draw lines
    const lines = [
        [
            [100, 100],
            [200, 200],
        ],
        [
            [220, 220],
            [260, 320],
        ],
    ]
    lines.forEach((line) => drawLine(ctx, line))
}
```

## Circles

A circle needs a center point and a radius:

```javascript
const circle = {
    center: { x: 150, y: 150 },
    radius: 50,
}

// Drawing a circle
function drawCircle(ctx, circle) {
    ctx.beginPath()
    ctx.arc(circle.center.x, circle.center.y, circle.radius, 0, Math.PI * 2)
    ctx.stroke()
}

// Check if point is inside circle
function pointInCircle(point, circle) {
    const dx = point.x - circle.center.x
    const dy = point.y - circle.center.y
    return dx * dx + dy * dy <= circle.radius * circle.radius
}

// Get point on circle at angle
function pointOnCircle(circle, angle) {
    return {
        x: circle.center.x + Math.cos(angle) * circle.radius,
        y: circle.center.y + Math.sin(angle) * circle.radius,
    }
}
```

## Rectangles

I represent rectangles either by their position and size, or by their corners:

```javascript
// Rectangle by position and size
const rect = {
    x: 100,
    y: 100,
    width: 200,
    height: 150,
}

// Rectangle by corners
const rect2 = {
    min: { x: 100, y: 100 },
    max: { x: 300, y: 250 },
}

// Drawing a rectangle
function drawRect(ctx, rect) {
    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height)
}

// Check if point is inside rectangle
function pointInRect(point, rect) {
    return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height
}

// Get rectangle center
function rectCenter(rect) {
    return {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2,
    }
}
```

## Practical Usage Examples

Here's how these primitives work together in practice:

```javascript
// Creating a grid of points
function createGrid(cols, rows, spacing) {
    const points = []
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            points.push({
                x: x * spacing,
                y: y * spacing,
            })
        }
    }
    return points
}

// Creating a polygon (points in a circle)
function createPolygon(sides, radius, center = { x: 0, y: 0 }) {
    const points = []
    for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2
        points.push({
            x: center.x + Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius,
        })
    }
    return points
}

// Connect points with lines
function connectPoints(points) {
    const lines = []
    for (let i = 0; i < points.length - 1; i++) {
        lines.push({
            start: points[i],
            end: points[i + 1],
        })
    }
    return lines
}
```

## Why Keep It Simple?

1. **Clarity**: Simple data structures are easy to understand and debug
2. **Flexibility**: Basic objects can be easily modified or extended
3. **Serialization**: Simple objects are easy to save/load as JSON
4. **Performance**: Basic structures have minimal overhead
5. **Portability**: These representations work anywhere

## Tips for Working with Primitives

1. **Consistency**: Choose one representation and stick to it
2. **Immutability**: Create new objects rather than modifying existing ones
3. **Helper Functions**: Create utility functions for common operations
4. **Type Checking**: Use TypeScript or JSDoc for better type safety
5. **Documentation**: Comment on the expected format of your shapes

```javascript
// Example of documenting shape format
/**
 * @typedef {Object} Point
 * @property {number} x - X coordinate
 * @property {number} y - Y coordinate
 */

/**
 * Calculates distance between two points
 * @param {Point} p1 - First point
 * @param {Point} p2 - Second point
 * @returns {number} Distance between points
 */
function distance(p1, p2) {
    const dx = p2.x - p1.x
    const dy = p2.y - p1.y
    return Math.sqrt(dx * dx + dy * dy)
}
```

This approach to geometric primitives has served me well in creative coding projects, game development, and data visualization. It's simple enough to understand quickly but powerful enough to build complex systems.

Remember: you can always add complexity later when needed, but starting simple makes your code more maintainable and easier to reason about.

TODO: don't forget vectors!!!!
