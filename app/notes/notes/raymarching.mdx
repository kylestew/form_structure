---
title: 'Raymarching'
summary: 'Raymarching, SDF, etc'
image: raymarching.png
---

```js
// @meta exec store:shaderRenderer
function createShaderRenderer(canvas, params = {}) {
    // Default shader is a simple gradient animation
    const defaultParams = {
        fragSource: `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));
                gl_FragColor = vec4(color, 1.0);
            }
        `,
        uniforms: {}, // Custom uniforms can be added here
    }

    // Helper function to format shader errors
    function formatShaderError(type, source, infoLog) {
        const lines = source.split('\n')
        const errorLines = infoLog.split('\n')

        // Extract line number from WebGL error message (format: "ERROR: 0:X: message")
        const lineMatch = infoLog.match(/ERROR: 0:(\d+):/)
        const errorLine = lineMatch ? parseInt(lineMatch[1]) : null

        let errorMessage = `\n${type} Shader Compilation Error:\n\n`

        if (errorLine !== null) {
            // Show context around the error (3 lines before and after)
            const start = Math.max(0, errorLine - 3)
            const end = Math.min(lines.length, errorLine + 2)

            errorMessage += 'Source code around error:\n'
            for (let i = start; i < end; i++) {
                const prefix = i === errorLine - 1 ? '>>> ' : '    '
                errorMessage += `${prefix}${i + 1}: ${lines[i]}\n`
            }
            errorMessage += '\n'
        }

        errorMessage += 'Error details:\n'
        errorLines.forEach((line) => {
            errorMessage += `  ${line}\n`
        })

        errorMessage += '\nFull shader source:\n'
        lines.forEach((line, i) => {
            errorMessage += `${i + 1}: ${line}\n`
        })

        return errorMessage
    }

    const mergedParams = { ...defaultParams, ...params }
    const uniforms = { ...mergedParams.uniforms }
    const startTime = Date.now() / 1000

    // Create canvas and get WebGL context
    const gl = canvas.getContext('webgl')
    if (!gl) {
        throw new Error('WebGL not supported')
    }

    // Create shader program
    const vertexShader = gl.createShader(gl.VERTEX_SHADER)
    gl.shaderSource(
        vertexShader,
        `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `
    )
    gl.compileShader(vertexShader)

    const fragShader = gl.createShader(gl.FRAGMENT_SHADER)
    gl.shaderSource(fragShader, mergedParams.fragSource)
    gl.compileShader(fragShader)

    // Check for shader compilation errors
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        const infoLog = gl.getShaderInfoLog(vertexShader)
        const errorMessage = formatShaderError(
            'Vertex',
            `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `,
            infoLog
        )
        throw new Error(errorMessage)
    }

    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
        const infoLog = gl.getShaderInfoLog(fragShader)
        const errorMessage = formatShaderError('Fragment', mergedParams.fragSource, infoLog)
        throw new Error(errorMessage)
    }

    // Create and link program
    const program = gl.createProgram()
    gl.attachShader(program, vertexShader)
    gl.attachShader(program, fragShader)
    gl.linkProgram(program)

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error('Program linking error: ' + gl.getProgramInfoLog(program))
    }

    // Create quad vertices
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])

    const vertexBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

    // Get uniform locations
    const uniformLocations = {
        iResolution: gl.getUniformLocation(program, 'iResolution'),
        iTime: gl.getUniformLocation(program, 'iTime'),
    }

    // Add custom uniform locations
    Object.keys(uniforms).forEach((name) => {
        uniformLocations[name] = gl.getUniformLocation(program, name)
    })

    function renderMe() {
        const width = canvas.width
        const height = canvas.height

        // Update viewport
        gl.viewport(0, 0, width, height)

        // Use shader program
        gl.useProgram(program)

        // Set up vertex attributes
        const positionLocation = gl.getAttribLocation(program, 'position')
        gl.enableVertexAttribArray(positionLocation)
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

        // Set uniforms
        gl.uniform2f(uniformLocations.iResolution, width, height)
        gl.uniform1f(uniformLocations.iTime, Date.now() / 1000 - startTime)

        // Set custom uniforms
        Object.entries(uniforms).forEach(([name, value]) => {
            const location = uniformLocations[name]
            if (location !== null) {
                if (Array.isArray(value)) {
                    switch (value.length) {
                        case 2:
                            gl.uniform2fv(location, value)
                            break
                        case 3:
                            gl.uniform3fv(location, value)
                            break
                        case 4:
                            gl.uniform4fv(location, value)
                            break
                        default:
                            gl.uniform1f(location, value[0])
                    }
                } else {
                    gl.uniform1f(location, value)
                }
            }
        })

        // Draw quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    }
    return renderMe
}
```

<Canvas id="canvas" width={512} height={512} subtitle="Demo" />

```javascript
// @meta exec load:shaderRenderer
const canvas = document.getElementById('canvas')

const fragSource = `
    precision highp float;
    uniform vec2 iResolution;
    uniform float iTime;

    void main() {
        vec2 uv = gl_FragCoord.xy / iResolution.xy;
        vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));
        gl_FragColor = vec4(color, 1.0);
    }
`

const render = createShaderRenderer(canvas, { fragSource })
function animate() {
    render()
    requestAnimationFrame(animate)
}
animate()
```

## Resources

https://blog.maximeheckel.com/posts/painting-with-math-a-gentle-study-of-raymarching/
