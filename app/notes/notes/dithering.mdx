---
title: 'Dithering'
summary: 'Exploring dithering techniques for their artistic applications'
image: dithering.png
---

```javascript
// @meta exec store:utils
function loadImageData(imagePath, callback) {
    const img = new Image()
    img.src = imagePath
    img.onload = () => {
        const w = img.width
        const h = img.height

        // draw into a canvas to get image data
        const canvas = document.createElement('canvas')
        canvas.width = w
        canvas.height = h
        const ctx = canvas.getContext('2d')
        ctx.drawImage(img, 0, 0, w, h)
        const imageData = ctx.getImageData(0, 0, w, h)

        callback(imageData)
    }
}

function getPixels(imageData) {
    const data = imageData.data
    const pixels = []

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i]
        const g = data[i + 1]
        const b = data[i + 2]
        pixels.push([r, g, b])
    }

    return pixels
}

function cloneImageData(ctx, imageData) {
    const copy = ctx.createImageData(imageData.width, imageData.height)
    copy.data.set(new Uint8ClampedArray(imageData.data))
    return copy
}

function processImageWithPixelFn(imageData, pixelFn) {
    const data = imageData.data
    for (let i = 0; i < data.length; i += 4) {
        const [r, g, b] = pixelFn(data[i], data[i + 1], data[i + 2])
        data[i] = r
        data[i + 1] = g
        data[i + 2] = b
        data[i + 3] = 255
    }
    return imageData
}
```

Dithering is a technique in digital graphics where noise or patterns (pixel variations) are introduced into an image in order to make edges or color transitions less noticable.

-   Randomize quantization error in an attempt to break up patterns such as color banding and flatness. ([Mach bands](https://en.wikipedia.org/wiki/Mach_bands))
-   Create the illusion of color depth in images on systems with limited color palettes ([wikipedia](https://en.wikipedia.org/wiki/Dither#Algorithms:~:text=Dithering%20is%20used%20in%20computer%20graphics%20to%20create%20the%20illusion%20of%20color%20depth%20in%20images%20on%20systems%20with%20a%20limited%20color%20palette.)).

<div style={{ width: '33.33%', marginTop: '1rem' }}>![Dithering](https://i.redd.it/nue4qaypfvxa1.png)</div>

## Random Dithering

Each pixel value is compared against a random threshold, resulting in a staticky image. Although this method does not generate patterned artifacts, the noise tends to swamp the detail of the image. Remember, the goal is to randomize the quantization error so its less noticeable to our eyes.

Thresholding - not a dithering algorithm itself, but a useful baseline. Each pixel value is compared against a fixed threshold, reducing image depth to 2-levels, black or white. (random dithering without the random)

```javascript
// @meta store:thresholdPixel
function thresholdPixel(r, g, b, threshold = 128) {
    const gray = 0.299 * r + 0.587 * g + 0.114 * b
    const value = gray >= threshold ? 255 : 0
    return [value, value, value, 255] // RGB and full alpha
}

function randomNarrowRangePixel(r, g, b) {
    const threshold = 128 + (Math.random() * 64 - 32) // Random value between 96-160
    return thresholdPixel(r, g, b, threshold)
}

function randomFullRangePixel(r, g, b) {
    const threshold = Math.random() * 255 // Random value between 0-255
    return thresholdPixel(r, g, b, threshold)
}
```

<div style={{ display: 'flex', gap: '1rem' }}>
    <Canvas id="canvas_random1" subtitle="Original" width={180} height={215} />
    <Canvas id="canvas_random2" subtitle="Threshold" width={180} height={215} />
    <Canvas id="canvas_random3" subtitle="Random Half Range" width={180} height={215} />
    <Canvas id="canvas_random4" subtitle="Random Full Range" width={180} height={215} />
</div>

```javascript
// @meta exec load:utils load:thresholdPixel
const canvasOriginal = document.getElementById('canvas_random1')
const ctxOriginal = canvasOriginal.getContext('2d')
const canvasThresholded = document.getElementById('canvas_random2')
const ctxThresholded = canvasThresholded.getContext('2d')
const canvasRandomHalf = document.getElementById('canvas_random3')
const ctxRandomHalf = canvasRandomHalf.getContext('2d')
const canvasRandomFull = document.getElementById('canvas_random4')
const ctxRandomFull = canvasRandomFull.getContext('2d')

loadImageData('/images/_notes/_resources/david.png', (imageData) => {
    ctxOriginal.putImageData(imageData, 0, 0)

    const thresholdCopy = cloneImageData(ctxThresholded, imageData)
    const randomHalfCopy = cloneImageData(ctxRandomHalf, imageData)
    const randomFullCopy = cloneImageData(ctxRandomFull, imageData)

    const processed = processImageWithPixelFn(thresholdCopy, thresholdPixel)
    ctxThresholded.putImageData(processed, 0, 0)

    const processedRandomHalf = processImageWithPixelFn(randomHalfCopy, randomNarrowRangePixel)
    ctxRandomHalf.putImageData(processedRandomHalf, 0, 0)

    const processedRandomFull = processImageWithPixelFn(randomFullCopy, randomFullRangePixel)
    ctxRandomFull.putImageData(processedRandomFull, 0, 0)
})
```

## Patterning

Patterning dithers using a fixed pattern. For each of the input values, a fixed pattern is placed in the output image. The biggest disadvantage of this technique is that the output image is larger (by a factor of the fixed pattern size) than the input pattern.

TODO: example

```python
# can be an artibtrary block size

# Define 2×2 binary patterns
patterns = {
    0: np.array([[0, 0], [0, 0]]),  # darkest
    1: np.array([[1, 0], [0, 0]]),
    2: np.array([[1, 0], [0, 1]]),
    3: np.array([[1, 1], [1, 1]])   # brightest
}

# Map image to 4 levels
quantized = (arr / 64).astype(int).clip(0, 3)

# Output array will be 2x size
h, w = arr.shape
out = np.zeros((h * 2, w * 2), dtype=np.uint8)


# Apply pattern to each pixel
for y in range(h):
    for x in range(w):
        pat = patterns[quantized[y, x]] * 255
        out[y*2:y*2+2, x*2:x*2+2] = pat

# Show results
display(img, Image.fromarray(out))
```

## Ordered Dithering

[Ordered dithering](https://en.wikipedia.org/wiki/Ordered_dithering) is simply random dithering with a pattern. Think of it like placing a screen over the image—each pixel is compared against a repeating grid of values (the pattern). This grid determines whether a pixel turns black or white (or another color), giving the image a distinct, often pixelated texture. The choice of pattern has a big impact on the final look.

The pattern is a threshold map. This can be run on GPU since each pixel is independent!

How do you choose the pattern?

-   Usually _Bayer Matrices_ which are small grids carefully designed to spread quantization error in a visually pleasing way, avoid hard artifacts, and create smooth gradients
-   Blue noise - optimzal high frequency noise patterns (slow to compute), can give a more natural look
-   Can hand make whatever you want!

### Bayer Matrices

Meant to be an optimal threshold matrix for any possible quantisation of color.

To generate a Bayer matrix, you can use the following matrix as the base:

$$
\mathbf{M}_2 = \frac{1}{4}
\begin{bmatrix}
0 & 2 \\
3 & 1
\end{bmatrix}
$$

Then recursively double the size of the matrix to get the next level...

$$
\mathbf{M}_4 = \frac{1}{16}
\begin{bmatrix}
0 & 8 & 2 & 10 \\
12 & 4 & 14 & 6 \\
3 & 11 & 1 & 9 \\
15 & 7 & 13 & 5
\end{bmatrix}
$$

And the next...

$$
\mathbf{M}_8 = \frac{1}{64}
\begin{bmatrix}
0 & 32 & 8 & 40 & 2 & 34 & 10 & 42 \\
48 & 16 & 56 & 24 & 50 & 18 & 58 & 26 \\
12 & 44 & 4 & 36 & 14 & 46 & 6 & 38 \\
60 & 28 & 52 & 20 & 62 & 30 & 54 & 22 \\
3 & 35 & 11 & 43 & 1 & 33 & 9 & 41 \\
51 & 19 & 59 & 27 & 49 & 17 & 57 & 25 \\
15 & 47 & 7 & 39 & 13 & 45 & 5 & 37 \\
63 & 31 & 55 & 23 & 61 & 29 & 53 & 21
\end{bmatrix}
$$

```javascript
// @meta store:generateBayerMatrix
/**
 * Generates a Bayer matrix for the given level
 * @param {number} n - The exponent n that determines matrix size (2^n x 2^n)
 * @returns {number[][]} The Bayer matrix
 */
function generateBayerMatrix(n) {
    if (n === 1) {
        return [
            [0, 2],
            [3, 1],
        ]
    }

    const prev = generateBayerMatrix(n - 1)
    const size = prev.length
    const newSize = size * 2
    const matrix = Array.from({ length: newSize }, () => Array(newSize).fill(0))

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const val = prev[y][x]
            matrix[y][x] = 4 * val
            matrix[y][x + size] = 4 * val + 2
            matrix[y + size][x] = 4 * val + 3
            matrix[y + size][x + size] = 4 * val + 1
        }
    }

    return matrix
}
```

<table id="bayer_matrix" />

Output of `generateBayerMatrix(3)` produces an 8x8 Bayer matrix $n = 3 \rightarrow 2^3 = 8$

```javascript
// @meta exec load:generateBayerMatrix
// Example usage: 4x4 Bayer matrix (n = 2 → 2^2 = 4)
const bayer = generateBayerMatrix(3)

// Create a table element to display the matrix
const table = document.getElementById('bayer_matrix')
table.style.borderCollapse = 'collapse'
table.style.margin = '1rem 0'
table.style.fontFamily = 'monospace'

// Clear existing table contents
while (table.firstChild) {
    table.removeChild(table.firstChild)
}

// Create table rows and cells
bayer.forEach((row) => {
    const tr = document.createElement('tr')
    row.forEach((cell) => {
        const td = document.createElement('td')
        td.textContent = cell
        td.style.padding = '0.7rem'
        td.style.border = '1px solid #ccc'
        td.style.textAlign = 'center'
        td.style.width = '2.7rem'
        td.style.height = '2rem'
        tr.appendChild(td)
    })
    table.appendChild(tr)
})
```

<div style={{ display: 'flex', gap: '1rem' }}>
    <Canvas id="canvas_ordered1" subtitle="Original" width={180} height={215} />
    <Canvas id="canvas_ordered2" subtitle="Bayer Matrix" width={180} height={215} />
    <Canvas id="canvas_ordered3" subtitle="Ordered Dithering" width={180} height={215} />
</div>

```javascript
// @meta exec load:utils load:generateBayerMatrix
const canvasOriginal = document.getElementById('canvas_ordered1')
const ctxOriginal = canvasOriginal.getContext('2d')
const canvasBayer = document.getElementById('canvas_ordered2')
const ctxBayer = canvasBayer.getContext('2d')
const canvasOrdered = document.getElementById('canvas_ordered3')
const ctxOrdered = canvasOrdered.getContext('2d')

// Generate 8x8 Bayer matrix
const bayerMatrix = generateBayerMatrix(3)
const matrixSize = bayerMatrix.length

// Display the Bayer matrix pattern
const bayerCanvas = document.createElement('canvas')
bayerCanvas.width = matrixSize
bayerCanvas.height = matrixSize
const bayerCtx = bayerCanvas.getContext('2d')
bayerCtx.imageSmoothingEnabled = false
const bayerImageData = bayerCtx.createImageData(matrixSize, matrixSize)

// Convert Bayer matrix to visual pattern
for (let y = 0; y < matrixSize; y++) {
    for (let x = 0; x < matrixSize; x++) {
        const value = (bayerMatrix[y][x] / (matrixSize * matrixSize - 1)) * 255
        const i = (y * matrixSize + x) * 4
        bayerImageData.data[i] = value
        bayerImageData.data[i + 1] = value
        bayerImageData.data[i + 2] = value
        bayerImageData.data[i + 3] = 255
    }
}
bayerCtx.putImageData(bayerImageData, 0, 0)

// Disable smoothing on destination canvas
ctxBayer.imageSmoothingEnabled = false
ctxBayer.drawImage(bayerCanvas, 0, 0, canvasBayer.width, canvasBayer.height)

// Load and process the image
loadImageData('/images/_notes/_resources/david.png', (imageData) => {
    // Display original
    ctxOriginal.putImageData(imageData, 0, 0)

    // Create a copy for dithering
    const ditheredCopy = cloneImageData(ctxOrdered, imageData)
    const data = ditheredCopy.data

    // Apply ordered dithering
    for (let y = 0; y < imageData.height; y++) {
        for (let x = 0; x < imageData.width; x++) {
            const i = (y * imageData.width + x) * 4

            // Convert to grayscale
            const r = data[i]
            const g = data[i + 1]
            const b = data[i + 2]
            const gray = 0.299 * r + 0.587 * g + 0.114 * b

            // Get corresponding Bayer matrix value
            const bayerX = x % matrixSize
            const bayerY = y % matrixSize
            const threshold = (bayerMatrix[bayerY][bayerX] / (matrixSize * matrixSize - 1)) * 255

            // Apply threshold
            const value = gray > threshold ? 255 : 0
            data[i] = value
            data[i + 1] = value
            data[i + 2] = value
            data[i + 3] = 255
        }
    }

    // Display dithered result
    ctxOrdered.putImageData(ditheredCopy, 0, 0)
})
```

### Comparing Different Bayer Matrix Sizes

<div style={{ display: 'flex', gap: '1rem' }}>
    <Canvas id="canvas_bayer1" subtitle="2x2 Matrix (n=1)" width={180} height={215} />
    <Canvas id="canvas_bayer2" subtitle="4x4 Matrix (n=2)" width={180} height={215} />
    <Canvas id="canvas_bayer3" subtitle="8x8 Matrix (n=3)" width={180} height={215} />
    <Canvas id="canvas_bayer4" subtitle="16x16 Matrix (n=4)" width={180} height={215} />
</div>

```javascript
// @meta exec load:utils load:generateBayerMatrix
const canvas1 = document.getElementById('canvas_bayer1')
const ctx1 = canvas1.getContext('2d')
const canvas2 = document.getElementById('canvas_bayer2')
const ctx2 = canvas2.getContext('2d')
const canvas3 = document.getElementById('canvas_bayer3')
const ctx3 = canvas3.getContext('2d')
const canvas4 = document.getElementById('canvas_bayer4')
const ctx4 = canvas4.getContext('2d')

// Disable image smoothing for all contexts
;[ctx1, ctx2, ctx3, ctx4].forEach((ctx) => (ctx.imageSmoothingEnabled = false))

// Function to apply ordered dithering with a specific matrix size
function applyOrderedDithering(imageData, bayerMatrix, ctx) {
    const ditheredCopy = cloneImageData(ctx, imageData)
    const data = ditheredCopy.data
    const matrixSize = bayerMatrix.length

    for (let y = 0; y < imageData.height; y++) {
        for (let x = 0; x < imageData.width; x++) {
            const i = (y * imageData.width + x) * 4

            // Convert to grayscale
            const r = data[i]
            const g = data[i + 1]
            const b = data[i + 2]
            const gray = 0.299 * r + 0.587 * g + 0.114 * b

            // Get corresponding Bayer matrix value
            const bayerX = x % matrixSize
            const bayerY = y % matrixSize
            const threshold = (bayerMatrix[bayerY][bayerX] / (matrixSize * matrixSize - 1)) * 255

            // Apply threshold
            const value = gray > threshold ? 255 : 0
            data[i] = value
            data[i + 1] = value
            data[i + 2] = value
            data[i + 3] = 255
        }
    }

    ctx.putImageData(ditheredCopy, 0, 0)
}

// Load and process the image with different matrix sizes
loadImageData('/images/_notes/_resources/david.png', (imageData) => {
    // Generate matrices of different sizes
    const matrix2x2 = generateBayerMatrix(1) // n=1 → 2x2
    const matrix4x4 = generateBayerMatrix(2) // n=2 → 4x4
    const matrix8x8 = generateBayerMatrix(3) // n=3 → 8x8
    const matrix16x16 = generateBayerMatrix(4) // n=4 → 16x16

    // Apply dithering with each matrix size
    applyOrderedDithering(imageData, matrix2x2, ctx1)
    applyOrderedDithering(imageData, matrix4x4, ctx2)
    applyOrderedDithering(imageData, matrix8x8, ctx3)
    applyOrderedDithering(imageData, matrix16x16, ctx4)
})
```

_Interesting note:_

"Bayer dithering" uses a Bayer matrix as the threshold map. They are named after Bryce Bayer, inventor of the [Bayer filter](https://en.wikipedia.org/wiki/Bayer_filter), which is in use to this day in digital cameras. Each pixel on the sensor can only detect brightness, but by cleverly arranging colored filters in front of the individual pixels, we can reconstruct color images through demosaicing. The pattern for the filters is the same pattern used in Bayer dithering.

### Blue Noise Dithering

TODO: this one seems complex

## Error Diffusion

TODO: An entirely new type

-   https://surma.dev/things/ditherpunk/#:~:text=Blue%20noise%20dithering.-,Error%20diffusion,-All%20the%20previous
-   https://en.wikipedia.org/wiki/Dither#:~:text=Error%2Ddiffusion%20dithering%20is%20a%20feedback%20process%20that%20diffuses%20the%20quantization%20error%20to%20neighboring%20pixels.
-   https://observablehq.com/@jobleonard/ordered-error-diffusion-dithering

## Resources

-   [Dither - Wikipedia](https://en.wikipedia.org/wiki/Dither)
-   [Ditherpunk](https://surma.dev/things/ditherpunk/)
-   [Dithering - Computerphile](https://www.youtube.com/watch?v=ico4fJfohMQ)
-   [Error Diffusion Dithering - Computerphile](https://www.youtube.com/watch?v=ico4fJfohMQ)
-   [The Art of Dithering and Retro Shading](https://blog.maximeheckel.com/posts/the-art-of-dithering-and-retro-shading-web/)
-   [Obra Dinn Dithering Explanation](https://forums.tigsource.com/index.php?topic=40832.msg1363742#msg1363742)

### Further Ideas

-   Ordered dithering with arbitrary patterns, custom patterns, non-repeating patterns
-   What happens if I re-dither a dithered output?
-   [WebGL example](https://codepen.io/kynd/pen/abMWgMe?editors=0010)
-   [Newer Dithering Algorithms](https://observablehq.com/@jobleonard/variable-coefficient-dithering)

http://caca.zoy.org/study/index.html
