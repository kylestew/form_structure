---
title: 'Heightfields: Visualizing Elevation Data in 2D'
publishedAt: '2024-04-09'
summary: 'Learn how to work with and visualize heightfield data using 2D graphics.'
image: heightfields.png
---

## Understanding Heightfields

A heightfield is a 2D array of height values that can represent terrain or other 3D surfaces. Each value in the array represents the elevation at that point. This note discusses and shows some interesting ways to work with heightfield data.

_Note: Heightfields cannot have overhangs since they are a one to one mapping of height values to x, y coordinates. An overhang or cave would require more than one height value per point._

### Data Structure

A basic heightfield can be represented as a 2D array where each value represents the elevation at that point.

```javascript
const heightfield = [
    [0.4, 0.6, 1.0, 0.5],
    [0.5, 0.7, 0.8, 0.6],
    [0.2, 0.5, 0.6, 0.4],
    [0.0, 0.2, 0.4, 0.2],
]
```

I prefer to use a 1D array and convert to 2D with proper indexing.

### Displaying a Heightfield

This is a simplified pixel exact rendering of a heightfield. It takes advantage of Canvas upscaling and forces pixels to be square. Canvas pixel data size and heightfield size should match.

```javascript
// Create an ImageData object to manipulate pixels directly
const imageData = ctx.createImageData(gridSize, gridSize)
const pixels = imageData.data // Uint8ClampedArray of RGBA values

// Iterate through each pixel in the image data
for (let i = 0; i < pixels.length; i += 4) {
    // Calculate x,y coordinates from the pixel index
    const x = (i / 4) % gridSize
    const y = Math.floor(i / 4 / gridSize)

    // Get height value from 1D heightfield array
    // values are expecte to be between 0-1
    const height = heightfield[y * gridSize + x]

    // Convert height to RGB color using color mapping function
    const [r, g, b] = getColor(height)

    // Set RGBA values in pixel array
    pixels[i] = r // Red
    pixels[i + 1] = g // Green
    pixels[i + 2] = b // Blue
    pixels[i + 3] = 255 // Alpha (fully opaque)
}

// Draw the image data to the canvas
ctx.putImageData(imageData, 0, 0)
```

```javascript
// @meta exec store:display
/**
 * Displays a heightfield on a canvas using a color mapping function
 * @param {CanvasRenderingContext2D} ctx - The canvas 2D rendering context
 * @param {number} gridSize - Size of the heightfield grid (must be square)
 * @param {number[]} heightfield - 1D array of height values between 0-1
 * @param {function} getColor - Function that takes a height value (0-1) and returns [r,g,b] color array
 * @returns {void}
 */
function displayHeightfield(ctx, gridSize, heightfield, getColor) {
    // Resize canvas if needed - the canvas data size needs to match the heightfield grid size
    if (ctx.canvas.width !== gridSize || ctx.canvas.height !== gridSize) {
        // maintain CSS display size
        ctx.canvas.style.width = `${ctx.canvas.width}px`
        ctx.canvas.style.height = `${ctx.canvas.height}px`

        ctx.canvas.width = gridSize
        ctx.canvas.height = gridSize
    }

    // disable image smoothing for sharp edges
    ctx.imageSmoothingEnabled = false
    ctx.canvas.style.imageRendering = 'pixelated'

    // Create an ImageData object to manipulate pixels directly
    const imageData = ctx.createImageData(gridSize, gridSize)
    const pixels = imageData.data // Uint8ClampedArray of RGBA values

    // Iterate through each pixel in the image data
    for (let i = 0; i < pixels.length; i += 4) {
        // Calculate x,y coordinates from the pixel index
        const x = (i / 4) % gridSize
        const y = Math.floor(i / 4 / gridSize)

        // Get height value from 1D heightfield array
        const height = heightfield[y * gridSize + x]

        // Convert height to RGB color using callback
        const [r, g, b] = getColor(height)

        // Set RGBA values in pixel array
        pixels[i] = r // Red
        pixels[i + 1] = g // Green
        pixels[i + 2] = b // Blue
        pixels[i + 3] = 255 // Alpha (fully opaque)
    }

    // Draw the image data to the canvas
    ctx.putImageData(imageData, 0, 0)
}
```

## Simple Heightfield

<Canvas id="example_simple" />

_White is 1.0, black is 0.0_

Create a heightfield array and fill with values from a simple math function.

```javascript
const gridSize = 64
let heightfield = new Float32Array(gridSize * gridSize)
for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
        const dx = x - gridSize / 2
        const dy = y - gridSize / 2
        const dist = Math.sqrt(dx * dx + dy * dy)
        heightfield[y * gridSize + x] = Math.sin(dist * 0.5)
    }
}
```

```javascript
// @meta exec load:display

// create and fill heightfield
const gridSize = 64
let heightfield = new Float32Array(gridSize * gridSize)
for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
        const dx = x - gridSize / 2
        const dy = y - gridSize / 2
        const dist = Math.sqrt(dx * dx + dy * dy)
        heightfield[y * gridSize + x] = Math.sin(dist * 0.5)
    }
}

const canvas = document.getElementById('example_simple')
const ctx = canvas.getContext('2d')
ctx.fillStyle = 'black'
ctx.fillRect(0, 0, canvas.width, canvas.height)

displayHeightfield(ctx, gridSize, heightfield, (height) => {
    // Map [-1,1] to [0,1] then to [0,255] for red channel
    const val = ((height + 1) / 2) * 255
    return [val, val, val]
})
```

## Terrain Generation

<Canvas id="example_terrain" />

_Terrain generation using FBM noise_

### Terrain Height Values

A simple way to generate terrain is to layer different noise functions together. This is a technique called [Fractal Brownian Motion (FBM)](https://iquilezles.org/articles/fbm/) popularized by [Inigo Quilez](https://iquilezles.org/). I also like the interactive explanation by [Patricio Gonzalez Vivo](https://patriciogonzalezvivo.com/) in his [The Book of Shaders](https://thebookofshaders.com/13/).

```javascript
// @meta exec store:simplex
// alias the noise function for the upcoming examples
const simplex2 = root.random.simplex2
```

We're using the simplex noise here instead of Perlin noise because it's faster to compute and produces better results for our use case.

```javascript
// @meta store:fbm
/**
 * Generates Fractal Brownian Motion noise by layering multiple octaves of simplex noise
 * @param {number} x - X coordinate to sample
 * @param {number} y - Y coordinate to sample
 * @param {number} scale - Base frequency scale. Higher values = more zoomed out noise
 * @param {number} octaves - Number of noise layers to combine
 * @param {number} persistance - How quickly amplitude decreases per octave (0-1)
 * @param {number} lacunarity - How quickly frequency increases per octave (typically 2)
 * @returns {number} Combined noise value between 0 and 1
 */
function noiseFBM(x, y, scale = 1.0, octaves = 4, persistance = 0.5, lacunarity = 2.0) {
    let amplitude = 1.0
    let frequency = scale
    let height = 0.0
    let maxAmplitude = 0.0
    for (let i = 0; i < octaves; i++) {
        height += simplex2(x * frequency, y * frequency) * amplitude
        maxAmplitude += amplitude

        amplitude *= persistance
        frequency *= lacunarity
    }
    return height / maxAmplitude
}
```

FBM noise can then be used to generate heightfield values.

```javascript
const scale = 0.005
const octaves = 6
const persistance = 0.4
for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
        heightfield[y * gridSize + x] = noiseFBM(x, y, scale, octaves, persistance)
    }
}
```

### Color Mapping

```javascript
// @meta store:terrainColors
const terrainColors = [
    [0.3, [0, 0, 128]], // Deep water (dark blue)
    [0.4, [0, 0, 255]], // Shallow water (blue)
    [0.45, [194, 178, 128]], // Sand (beige)
    [0.6, [0, 170, 0]], // Grass 1 (darker green)
    [0.7, [0, 255, 0]], // Grass 2 (lighter green)
    [0.8, [96, 96, 96]], // Rock 1 (darker gray)
    [0.9, [160, 160, 160]], // Rock 2 (lighter gray)
    [1.0, [255, 255, 255]], // Snow (white)
]

function getTerrainColor(height) {
    for (let i = 0; i < terrainColors.length; i++) {
        const [level, rgb] = terrainColors[i]
        if (height <= level) {
            return rgb
        }
    }
    return [255, 255, 255] // Default to snow (fallback)
}
```

```javascript
// @meta exec load:simplex load:fbm load:display
// === EXAMPLE TERRAIN GENERATION ===
const canvas = document.getElementById('example_terrain')
const ctx = canvas.getContext('2d')
ctx.fillStyle = 'black'
ctx.fillRect(0, 0, canvas.width, canvas.height)

// create heightfield to match canvas pixel size
const gridSize = canvas.width
let heightfield = new Float32Array(gridSize * gridSize)

// sample FBM
for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
        heightfield[y * gridSize + x] = noiseFBM(x, y, 0.005, 6, 0.4)
    }
}

// TODO: normalize?

displayHeightfield(ctx, gridSize, heightfield, (height) => {
    // Map [-1,1] to [0,1] then to [0,255] for red channel
    const val = ((height + 1) / 2) * 255
    return [val, val, val]
})

/*
// normalize values
function normalizeHeightfield(heightfield) {
    let min = Infinity
    let max = -Infinity

    // Find min and max values manually (avoids large array spread issue)
    for (let i = 0; i < heightfield.length; i++) {
        if (heightfield[i] < min) min = heightfield[i]
        if (heightfield[i] > max) max = heightfield[i]
    }

    // Avoid division by zero if all values are the same
    if (max === min) {
        return heightfield.map(() => 0.5) // Default to mid-range if no variation
    }

    // Normalize values
    return heightfield.map((value) => (value - min) / (max - min))
}
heightfield = normalizeHeightfield(heightfield)
*/
```

## Better Terrain

From the video series

## Common Operations

### Smoothing

Smoothing can help reduce noise in heightfield data:

```javascript
function smoothHeightfield(heightfield) {
    const result = Array.from(heightfield.map((row) => [...row]))
    const height = heightfield.length
    const width = heightfield[0].length

    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            // Average with neighboring cells
            result[y][x] =
                (heightfield[y - 1][x] +
                    heightfield[y + 1][x] +
                    heightfield[y][x - 1] +
                    heightfield[y][x + 1] +
                    heightfield[y][x]) /
                5
        }
    }
    return result
}
```

## TODO: load GIS heightfield data?

## Resources

-   [Digital Elevation Model Data](https://www.usgs.gov/programs/national-geospatial-program/national-map)
-   [Terrain Generation Algorithms](https://en.wikipedia.org/wiki/Terrain_generation)
-   [GIS Fundamentals](https://www.gislounge.com/category/gis-fundamentals/)

https://www.sidefx.com/docs/houdini/model/heightfields.html

https://www.michaelfogleman.com/projects/hmm/
https://www.michaelfogleman.com/projects/terrarium/
https://www.michaelfogleman.com/projects/pirate-maps/
https://www.michaelfogleman.com/projects/hirise/

### Further Study

Relation to heightmaps???

https://heman.readthedocs.io/en/latest/overview.html
